---
layout: post
title:  "1강: 인트로"
date:   2022-05-13-12-00
categories: 이론전산학의_위대한_발상들
---
*이 카테고리는 스콧 애론슨(Scott Aaronson)이 MIT 재직 시절 가르친 수업 '이론전산학의 위대한 발상들'(Great Ideas In Theoretical Computer Science, 2008) 강의 노트를 번역한 것이다. 작성(scribe)은 스콧의 TA였던 Yinmeng Zhang이 맡은 것으로 보인다. 수업에 관한 자세한 사항은 [이 링크](http://stellar.mit.edu/S/course/6/sp16/6.045/materials.html)를 참고하라.*

## 1. 행정 관련 잡무
'이론전산학의 위대한 발상들'에 온 것을 환영한다. 강의 정보에 관해서는 [강의계획서](http://stellar.mit.edu/S/course/6/sp16/6.045/courseMaterial/topics/topic1/syllabus/syllabus2016/syllabus2016.pdf)를 참고 바란다. 

이 수업에 대한 유일한 필요 조건은 "수학적 성숙함"이다. 이는 증명을 다룰 줄 안다는 것을 뜻한다. 증명이란 무엇인가? 증명에는 형식적인 정의가 있다. 각 명제는 명세 규칙에 따라 선행 명제에서 따라 나와야 한다. 이는 우리가 이 강의에서 배울 정의다. 하지만 당신이 숙제를 할 적에는 무방한 정의다. 이 수업에서 증명이란 고도로 카페인에 찌든 적수(敵手, highly caffeinated adversary)가 내놓는 모든 비판에 맞설 수 있는 주장을 뜻한다.

무엇이라도 불명확하면 끼어들어 달라. 가장 단순한 질문은 이따금 가장 좋은 것들이다. 신나지 않고 몰입되지 않는다면 불평하라.

## 2. 컴퓨터 과학이란 무엇인가?

컴퓨터 과학은 프로그래밍을 미화한 것이 아니다. 튜링상 수상자이자 극도로 독선적인 인간인 에츠허르 데이크스트라(Edsger Dijkstra)는 다음과 같은 유명한 말을 남긴 바 있다. 컴퓨터 과학은 컴퓨터와 마치 천문학이 망원경과 관련되는 정도로만 관련된다. 우리는 다음처럼 주장한다. 컴퓨터 과학은 임의의 체계를 이해하기 위한 수학적 도구의 집합 또는 발상의 몸체다. 여기서 체계란 다음을 포함한다. 뇌, 우주, 생물, 또는, 물론, 컴퓨터. 유년 시절 스콧은 비디오 게임을 이해하고 싶었다. 그래서 컴퓨터 과학에 진입했다. 그러나 그에게는 비디오 게임을 진정으로 이해하면 우주 전체를 이해할 수 있으리라는 것이 명백했다. 결국 우주란 아주, 아주 사실적인 특수 효과를 지닌 비디오 게임이 아니라면 무엇이겠는가?

OK. 하지만 물리학이야말로 우주를 이해하기 위해 용인되는 학술적인 길이 아니던가? 자, 물리학자는 당신이라면 상향식 접근법이라고 부를 법한 것을 취한다. 규칙적인 패턴을 찾고 일반 법칙으로 이들을 일괄하려고 하며, 이들 법칙을 더 심층적인 법칙으로 설명한다. [대형 강입자 충돌기](https://en.wikipedia.org/wiki/Large_Hadron_Collider)는 일 년 안에 더 깊게 파고들 것으로 계획되어 있다.

컴퓨터 과학은 말하자면 반대 방향으로 작동한다고 생각할 수 있다. (중간에서 결국에는 물리학자랑 마주칠 수도 있다.) 우리는 가능한 가장 단순한 체계와 실험에 의해 꼭 확증된 것만은 아니지만 참으로 가정하는 일련의 규칙에서 시작한다. 그런 다음 우리가 만들 수 있고 만들 수 없는 복잡한 체계의 종류를 묻는다.

## 3. 학생 교정용 질문

*콰인*(quine)은 그 자신을 출력하는 프로그램이다. 이런 프로그램을 본 적 있는가? 이런 프로그램을 작성할 수 있는가?

아래는 영어로 작성한 콰인이다.

```
Print the following twice, the second time in quotes.
"Print the following twice, the second time in quotes."
```

어쩌면 가장 흥미진진한 자기 복제 프로그램은 생물일 것이다. DNA는 콰인과 살짝 다르다. 돌연변이와 성(性)이 있기 때문이다. 어쩌면 후일 더 있을 수도 있다.

무한에도 다른 종류가 있다는 것을 아는가? 특히 정수보다 실수가 더 많다. 정수와 짝수 정수의 수가 같은데도 말이다. 이에 관해서는 강의 후반에 얘기할 것이다. 그리고 인간 사고의 더없는 성취 가운데 하나로 볼 것이다.

## 4. 온라인 도박 사이트를 어떻게 구동할 것인가?

다음은 "이론전산학의 위대한 발상들"의 일례다. 구미가 당기게 만들기 위해 준비했다. 

우리가 인터넷상에서 간단한 유형의 룰렛을 플레이하고자 할 적에 무슨 일어나는지 살펴보자. 

우리는 동일한 짝수 개수의 부분으로 나뉜 원반을 지니고 있다. 원반의 절반은 붉은색이며 절반은 검은색이다. 플레이어는 $$n$$ 달러를 붉은색이나 검은색에 배팅한다. 공은 원반 위를 구르고 동일한 확률로 임의의 부분에 안착한다. 공이 플레이어의 색깔에 안착하면 플레이어는 $$n$$ 달러를 딴다. 그렇지 않다면 $$n$$ 달러를 잃는다. 그리고 하우스에 대해 일정액 수수료가 있다. 플레이어가 $$1/2$$ 확률로 이긴다는 점에 주목하라. 이 게임의 대안적인 정식화는 "[수화기 너머로 동전 던지기](https://www.jstor.org/stable/2689924)"이다. 

이 게임을 구현하며 무엇이 잘못될 수 있을까? 다음을 상상해 보라.

>플레이어: 빨강에 배팅한다.
>
>카지노: 공은 검정에 착지했다. 당신이 졌다.
>
>플레이어: 검정에 배팅한다.
>
>카지노: 공은 빨강에 착지했다. 당신이 졌다.
>
>플레이어: 검정에 배팅한다.
>
>카지노: 공은 빨강에 착지했다. 당신이 졌다.
>
>플레이어: 빨강에 배팅한다.
>
>카지노: 공은 검정에 착지했다. 당신이 졌다.
>
>플레이어: 이 #$%망할 게임 사기야!

그러니까 사실 플레이어는 그가 충분히 자주 플레이하여 카지노가 그에게 $$50-50$$과 현저히 다른 승률을 부여한다면 \[사기를\] 깨달을 수도 있는 셈이다. 하지만 플레이어가 단 한 차례의 게임을 플레이하더라도 우리가 승률을 보장하고자 한다면 우리는 무엇을 할 수 있는가?

우리는 플레이어가 배팅하기 전에 카지노가 던진 공에 책임지도록 시도할 수도 있다. 다만 우리는 주의해야 한다.

>카지노: 공은 검정에 착지했다.
>
>플레이어: 재밌네, 나 검정에 배팅했거든!

우리는 또한 카지노가 공을 던지기 전에 플레이어가 배팅에 책임을 지도록 만들어야 한다. 물리적인 카지노에서는 이를 측정하여 플레이어가 배팅하기 전에 카지노가 동을 던지고 배팅 이후에야 공이 착지하도록 하는 것이 가능하다. 하지만 패킷이 손실되고(packet-dropping) 과정 중에 여러 다른 문제들이 발생할 수 있는 가운데, 인터넷상에서 그처럼 섬세한 시간 측정 기법을 구현할 수 있을지는 명확하지 않다.

이를 고칠 방법 가운데 하나는 신뢰하는 제삼자를 호출하는 것일 테다. 제삼자는 플레이어와 카지노에 대해 중간자 역할이 될 수 있을 것이다. 제삼자는 배팅을 수신한 다음 양측에서 정보를 던지면(throw) 모두 수신한 다음에야 이들을 전달할 것이다. 하지만 믿을 자가 누가 있겠는가?

또 다른 접근법은 컴퓨터 과학자에게 극도로 유익해 온 것이다. 바로 한쪽 또는 양측이 제한된 계산 능력을 지닌다고 가정하는 것이다.

## 5. 인수분해는 어려워

두 수를 곱하는 일은 꽤 쉽다. 초등학생 시절 우리는 곱셈을 위한 알고리즘을 배웠다. 이 알고리즘은 두 $$N-$$ 자릿수 수를 곱하는 데 $$N^2$$ 가량의 스텝을 취했다. 오늘날에는 아주 영리한 알고리즘이 있다. 이 알고리즘은 $$N\log N$$ 시간에 아주 근접하게 곱셈을 수행한다. 이는 $$1,000$$ 자릿수 수에 대해서도 충분히 빠르다.

초등학생 시절 우리는 또 그 역에 해당하는 연산인 인수분해를 배웠다. 하지만 "그냥 모든 가능한 인수를 시도"해 보는 것은 그다지 정밀하지 못하다. 수 $$X$$의 길이가 $$N$$ 비트라면 시도할 인수가 $$2^N$$ 개다. 우리가 영특하여 오직 $$X$$의 제곱근의 인수까지 시도하더라도 $$2^{N/2}$$ 개다. 그러니까 대신 뭘 할까? 양자 컴퓨터가 있다면 든든하겠다. 하지만 아마 없을 테다. 수 세기 간의 연구에 이어 최대 판돈은 (가우스(Gauss)는 이 질문에 굉장히 분명하게 관심을 보였다) 이른바 *수체 체*(number field sieve)로 판명났다. 이는 지수 시간을 거칠게 $$N^{1/3}$$이라는 상수 시간으로 향상했다.

곱셈은 쉽게 수행할 수 있지만 되돌리기는 굉장히 어려운 연산으로 보인다. 물리학에서 이는 일반적인 현상이다. 미시적인 수준에서 모든 절차는 나아갈 수도 되감을 수도 있다. 전자가 광자를 내뿜을 수 있으면 마찬가지로 흡수할 수도 있다. 등등. 다만 거시적인 관점에서는 다르다. 계란이 스크램블 에그가 되는 광경은 항상 볼 수 있지만 스크렘블 에그가 계란이 되는 상황은 절대 볼 수 없다. 컴퓨터 과학자들은 두 개의 큰 정수를 곱하는 일이 후자에 해당하는 연산이라고 가정한다. 수행하기는 쉽지만 되돌리기는 (고전적 컴퓨터로는) 엄청나게 어렵다는 것이다.

우리의 목적을 위해 살짝 더 강하게 가정하자. 인수분해만이 어려울 뿐 아니라, 인수 가운데 하나의 마지막 자릿수가 $$7$$인지 결정하는 것 또한 어렵다. (모두 알다시피 이 가정은 참이다.) 이제 플레이어는 빨강에 배팅하기 위해 $$7$$로 끝나지 않는 두 정수를 골라 이 둘을 곱한다. 검정에 배팅하기 위해서는 적어도 하나는 $$7$$로 끝나는 두 정수를 골라 이 둘을 골라 $$X$$를 취한다.

>플레이어: $$X$$를 카지노에 보낸다.
>
>카지노: 빨강 또는 검정이라고 발표한다.
>
>플레이어: 인수를 카지노에 공개한다.
>
>카지노: 인수를 곱하면 $$X$$가 나오는지 확인한다.

이는 좋은 프로토콜인가? 카지노는 사기를 칠 수 있는가? 플레이어는 어떤가? 플레이어는 세 정수의 곱인 수를 넘김으로써 사기를 치려고 할 수도 있다. 가령 인수가 $$A,B,C$$이고 이들이 $$1,3,7$$로 끝난다고 해보자. 그렇다면 카지노가 빨강이라고 발표할 때 플레이어는 수 $$AB$$와 $$C$$를 보낼 수도 있다. 카지노가 검정이라고 발표할 때 플레이어는 $$A$$와 $$BC$$를 보낼 수 있다. 즉 플레이어는 어떻게든 이긴다. 하지만 전혀 희망이 없는 것은 아니다. 밝혀진 바, 하나의 수가 비단순 인수를 지니는지 확인하는 것은 실제로 이들 인수를 생산하는 것과는 굉장히 다른 문제다. 한 수가 소수인지 합성수인지 알고자 한다면 이를 위한 효율적인 알고리즘이 있다. 그러니 우리는 그저 다음처럼 말하도록 마지막 단계를 조정하면 된다. "카지노는 인수가 소수인지 그리고 곱하면 $$X$$가 나오는지 확인한다."

이는 가능하다고 밝혀진 여러 이상한 일의 맛보기다. 다음에 우리는 누군가에게 그것이 참인 이유에 대한 어떤 단초조차 제공하지 않으면서 한 명제를 설득하는 방법을 살필 것이다. 아니면 다른 사람에게 어떤 명제가 참이라는 것을 설득하는 능력에 관해 살필 것이다. 우리는 임의의 명제를 특수한 포맷으로 "컴파일"하는 방법을 살필 것이다. 즉 증명을 확인하려고 하는 사람이라면 누구든 그저 임의의 비트 몇 개만 확인하면 된다. 증명의 크기와 무관하게 말이다! 그렇게 그것이 옳다는 점에 대해 아주 자신감 넘치면 된다. 이들 반직관적인 일이 가능하다는 사실은 세상이 돌아가는 방식에 관한 발견이다. 물론 모두가 이들 발상에 관해 기술적인 디테일까지 알려고 하지는 않는다. 모두가 양자역학을 진지하게 공부하려고 하지는 않는 것과 마찬가지다. 하지만 스콧의 의견에 따르면 과학 교육을 받은 이라면 적어도 이들 위대한 발상이 존재한다는 사실을 자각하고는 있어야 한다. 

## 6. 컴퍼스와 직선자

이제 우리는 컴퓨터 과학의 전사(前事)로 돌아간다. 고대 그리스인의 시간으로. 고대 그리스인은 계산의 형식 모델에 아주 관심이 많았다. 이는 *컴퍼스-직선자 작도*(compass-straightedge constructions)라고 부른다. 평면상에 컴퍼스와 직선자로 어떤 종류의 형상을 그릴 수 있는가? 규칙은 다음과 같다.

>우리는 두 점으로 시작한다. 이들 두 점 간의 거리(distance)는 단위길이를 정의한다.
>
>우리는 임의의 두 점 사이에 하나의 선을 그릴 수 있다.
>
>우리는 그 중심과 원주에 대해 하나의 점이 주어지면 하나의 원을 그릴 수 있다.
>
>우리는 앞서 작도된 두 임의의 대상들의 교점에 하나의 점을 그릴 수 있다.

![compass](https://user-images.githubusercontent.com/104351090/168387238-30b8460b-f07c-47db-91b2-4540412c7399.png)

이들 규칙을 반복해서 적용하여 우리는 온갖 유형의 대상을 작도할 수 있다. 위 그림은 한 선분의 수직 이등분선을 작도한 것이다. \[이를 증명할 수 있는가?\] 1796년 가우스는 정$$17$$각형을 작도했다. 가우스는 이것이 너무 자랑스러워 그의 묘지에 새겨달라고 청했다. (듣자 하니 조각가가 그냥 원처럼 보일 것이라며 거부했다고 한다.) 원리상 정$$65535$$각형을 작도하는 것이 가능하지만 짐작건대 아무도 실제로 이를 하지는 않았다. 실제로 형상을 그리는 대신 우리는 이들에 관해 추론할 수 있다. 환상적으로 복잡한 작도에 대한 실마리는 *모듈성*(modularity)이다. 가령 우리에게 수직선을 작도하기 위한 알고리즘이 있다면 우리는 이를 수직선 서브루틴으로 캡슐화할(encapsulate) 것이다. 다음에 수직선이 필요할 때면 우리는 이를 밑바닥부터 만들 필요가 없다. 가정하면 된다.

이런 방식으로 선행 작업을 토대로 수 세기 동안 인류는 기하학의 진실된 대성당을 세웠다. 그리고 수 세기 동안 생산 규칙의 이와 같은 조작은 무언가에 관해 명확하게 사고한다는 것의 정전(正典)과 같은 범례(範例)였다. 하지만 게임은 자기 자신의 한계를 가리켰다. 어떤 작도는 기하학자들을 혼란에 빠뜨렸다. 이들 가운데 유명한 예를 들면 다음과 같다. 원과 면적이 같은 사각형 만들기(squaring the circle), 각의 삼등분, 입방 배적 문제 (立方倍積問題).

오늘 우리는 입방 배적 문제에 관해 얘기할 것이다. 이 문제에는 입방체(cube)의 변 길이가 주어진다. 그리고 본래 입방체 부피의 두 배에 해당하는 부피를 지니는 새로운 입방체의 변 길이를 작도하라는 것이 문제다. 달리 말해 한 단위 길이 선분이 주어졌을 때 $$\sqrt[3]{2}$$ 길이의 선분을 작도하는 것이다. 제작 규칙을 추가할 수 있다고 가정하고 임의적으로 잘 근사하면 해낼 수 있는 일이다. 하지만 그 누구도 직선자와 컴퍼스만으로는 정확한 작도를 제시하는 데 성공한 바 없다.

1800년대의 기하학자들은 한 발짝 떨어져서 규칙의 근본적인 한계에 관한 메타 질문들을 던지기 시작했다. 다분히 컴퓨터 과학스러운 일이라고 말할 수 있겠다. 그들이 이런 물음은 그리스 지역을 합병한 이래 나타난 몇 가지 혁명적인 발상으로 인해 가능한 것이었다.

이들 발상 가운데 첫째는 데카르트 좌표였다. 1600년대 데카르트(Descartes)의 이름을 딴 것이다. 데카르트 좌표는 게임을 데카르트 평면으로 옮겨 놓는다. 최초의 점은 $$(0,0)$$과 $$(1,0)$$이다. $$(a,b)$$에서 $$(c,d)$$에 이르는 하나의 비(非)수직선은 함수 $$y=\frac{d-b}{c-a}x+\frac{ad-bc}{a-c}$$로 묘사된다. $$(a,b)$$를 중점으로 지니며 $$(c,d)$$를 지나가는 하나의 원은 함수 $$(x-a)^2+(y-b)^2=(a-c)^2+(b-d)^2$$를 지닌다. 교점은 연립방정식의 해다. 교선의 경우 이것이 단순한 선형계이기에 해를 구하기 쉽다. 하나의 선과 원 또는 원과 원의 경우 우리는 2차 방정식을 취하게 되고 근의 공식으로 해를 유도할 수 있다.

최종적인 결말은 우리가 얼마나 많은 연립 방정식을 풀고 새로운 점을 그리더라도 우리가 하는 일이라고는 전부 본래 좌표를 취해서 $$+,-,\times,\div$$하고 제곱근을 취하는 것이다. 실상 우리의 목적에는 문제를 다음처럼 재해석하는 편으로 충분할 것이다. 우리는 $$0$$과 $$1$$이라는 수로 시작한다. 그런 다음 위의 연산을 우리가 원하는 만큼 자주 적용한다. ($$0$$ 나눗셈은 불가능하지만 음수 제곱근은 괜찮다는 점에 유의하라.) 이들 연산으로 $$\sqrt[3]{2}$$를 작도할 수 있는가?

우리는 제곱근으로 빈둥거리면서 입방체를 제작하면 안 될 것만 같다. 그리고 사실 그렇게 되지도 않는다. 갈루아 이론을 사용하는 정말 재치 있는 증명이 있다. 그런데 여기서는 다루지 않을 것이다. 왜냐하면 갈루아 이론을 요구하기 때문이다.

이 예제는 역사적으로 순수 수학의 일부다. 그런데도 오늘날 이론전산학을 예시(予示)하는 여러 주제를 묘사한다. 잘 정의된(well-defined) 허용된 연산들이 있다. 이들 연산을 이용해서 온갖 유형의 아름답고 복잡한 구조를 만든다. 종종 이전에 만든 구조를 재사용해 심지어 더 복잡한 것을 만든다. 하지만 또 어떤 유형의 구조는 만들 수 *없는* 것으로 보인다. 그리고 그럴 때는 메타 추론에 몰입해야 한다. 규칙 자체에서 한 발짝 물러나야 한다. 그리고 자기 자신에게 물어야 한다. 이들 규칙이 *정말* 하는 게 뭔가? 이들 규칙이 우리에게 원하는 것을 절대 주지 않을 어떤 근본적인 이유가 있는가?

컴퓨터 과학자로서 우리는 특히 `AND`와 `OR`와 `NOT` 또는 `jump-if-not-equal`과 여타 디지털 연산으로 뭘 만드는 일에 관심을 갖는다. 우리는 여전히 이들 규칙의 근본적인 한계를 이해하고자 한다. 규칙이 *임의로 여러 번* 적용되었을 때 우리는 실상 이제 무엇이 가능하고 가능하지 않은지 꽤 잘 이해한다는 점에 유의하라. 이것이 *계산 가능성 이론*(computability theory)이라는 주제다. 곧 다루게 될 것이다. 하지만 만약 우리가 우리 자신을 "합리적인" 규칙 적용 횟수에 제한한다면 (유명한 $$\mathsf{P}$$ vs $$\mathsf{NP}$$ 문제처럼) 바로 지금 우리는 한 발짝 물러나 우리에게 무엇이 가능한지 알려주는 메타 추론의 일종에 몰두할 수 없었을 것이다.

## 7. 유클리드의 GCD 알고리즘

고대에서 비롯하는 계산적 사고의 또 다른 예는 정말 경이로우며 진보적이며 효율적인 것으로 바로 유클리드(Euclid)의 GCD 알고리즘이다. 다음 질문으로 시작한다.

>$$510/646$$과 같은 분수를 어떻게 기약 분수로 약분할 수 있는가?

물론 우리는 우리가 최대공약수(이하: GCD)를 취해야 한다는 것을 알고 있다. 그걸 어떻게 하는가? 초등학교에서 배우는 방법은 두 수를 인수분해하는 것이다. 모든 공통 소인수를 곱한 것이 GCD다. 그리고 우리는 간단하게 이들을 소거한다. 하지만 앞서 말했듯이 인수분해는 어렵다고 생각된다. 브루트 포스(brute force) 방법은 초등학생 문제에는 OK겠다. 하지만 $$1,000$$ 자릿수에는 돌아가지 않을 것이다. 하지만 하나의 수가 소수인지 합성수인지 검증하는 것과 마찬가지로 GCD 문제 또한 다른, 더 영리한 방법으로 해결될 수 있다. 인수분해를 요구하지 *않는* 방법이다.

유클리드가 영리하게 관찰한 바는 다음과 같다. 하나의 수가 $$510$$과 $$646$$과 같은 두 수를 나눈다면 그 하나의 수는 또한 두 수의 선형 조합에 해당하는 $$646-510$$과 같은 모든 정수를 나눈다. \[왜 그런지 알겠는가?\] 일반적으로 우리가 $$B$$를 $$A$$로 나눌 때 우리는 몫 $$q$$와 나머지 $$r$$을 방정식 $$B=qA+r$$과 연결된 채로 취한다. 이는 $$r=B-qA$$를 뜻한다. 또 이는 $$r$$이 $$A$$와 $$B$$의 선형 조합이라는 것을 뜻한다!

따라서 $$510$$과 $$646$$의 GCD를 찾는 일은 우리가 $$646$$과 $$510$$을 나눌 때 그 나머지와 $$510$$의 GCD를 찾는 일과 같다. 훌륭하다. 왜냐하면 그 나머지는 더 작은 수이기 떄문이다. 우리는 진척을 이뤘다!

$$
\textrm{GCD}(510,646)=\textrm{GCD}(136,510)
$$

그리고 우리는 같은 일을 계속 할 수 있다.

$$
\textrm{GCD}(136,510)=\textrm{GCD}(102,136)=\textrm{GCD}(34,102)=34
$$

여기서 우리는 멈췄는데 왜냐하면 $$34$$가 $$102$$를 나누기 때문이다. 그리고 우리는 이것이 의미하는 바를 알고 있다. $$34##는 $$34$$와 $$102$$의 GCD다. 우리는 한 단계 더 나아갈 수도 있다. 그런 다음 모든 숫자와 $$0$$의 GCD는 그 숫자라는 사실을 강조할 수 있다. $$\textrm{GCD}(34,102)=\textrm(0,34)=34$$.

```
GIVEN: natural numbers A, B
Assume B is the larger (otherwise swap them)
If A is 0 return B
Else find the GCD of (B % A) and A
```

수는 매번 작아지고 우리가 지금 다루는 것이 자연수이기에 우리는 우리가 $$0$$에 이를 것임을 알고 있다. 따라서 유클리드의 알고리즘이 종국에는 마무리되어 답을 반환할 것이다. 하지만 정확히 얼마나 많은 나머지가 요구될 것인가? 자, 이들 수는 매번 얼만큼 작아질 것인가? 우리는 다음처럼 주장한다. $$(B\textrm{ mod }A)<B/2$$.
왜 그런지 알겠는가? (힌트: $$A$$가 $$B/2$$보다 크거나 작거나 같은 경우에 따라 생각한다.) 따라서 수들은 *지수적으로*(exponentially) 작아진다. 여타 모든 등호마다 수들은 그전보다 절반 가량 커졌다. $$102<510/2$$, $$136<646/2$$, 이런 식으로 이어진다. 인은 유클리드 알고리즘이 꽤 훌륭하다는 것을 뜻한다.

질문: 여러 병렬 프로세서가 있다면 유클리드 알고리즘의 속도를 향상할 수 있는가?

각 스텝별로 작업의 속도를 향상할 수 있다. 영리한 병렬 나눗셈 알고리즘을 통해 말이다. 하지만 더 영리한 일을 해내는 것은 불가능하다. 각 스텝이 이전 스텝의 출력에 의존하기 때문이다. 이 알고리즘을 병렬화할 수 있는 방법을 찾는다면 2300년만에 처음으로 진정 공격적인 향상을 발견해낸 셈이다. 

## 8. 추가 참고 자료에 대해

"[컴퍼스와 직선자](https://en.wikipedia.org/wiki/Straightedge_and_compass_construction)", "[수체 체](https://en.wikipedia.org/wiki/General_number_field_sieve)", "[에츠허르 데이크스트라](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra)" 등에 대한 위키피디아 문헌을 확인해 보라.