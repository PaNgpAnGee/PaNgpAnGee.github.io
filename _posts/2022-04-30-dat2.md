---
use_math: true
layout: post
title:  "계산기 구현하기"
date:   2022-04-30-17-03
categories: 자료구조
---
*카이스트 이산 및 전산 기하학 연구실 [오프트리트 정 교수님의 2017년 자료구조 강의 노트](https://otfried.org/courses/cs206/) 번역*
## 토큰화와 파싱
계산기는 어떻게 (단지 문자열에 불과한) 산술 표현식에서 표현식의 값을 취할 수 있는가? 

이 물음은 프로그래밍 언어에 대한 인터프리터나 컴파일러 안에서 무슨 일이 일어나는지에 대한 아주 단순한 판본이다. (가령 웹브라우저에 내장된 자바스크립트 인터프리터, 엑셀, 메이플, 매트랩의 매크로 언어나 파이썬의 인터프리터 자체)

일반적으로 이 과정은 세 단계로 구성된다. **어휘 분석, 구문 분석, 의미 분석**.
## 어휘 분석
어휘 분석(**토큰화**)는 (문자열 또는 텍스트 파일의) 입력 텍스트를 가장 작고 의미있는 단위로 쪼갠다. 이들 가장 작은 단위는 **토큰**이라고 부르며 어휘 분석기 또한 **토큰화 장치**(tokenizers)라고 부른다.

우리의 계산기에 대해 우리는 네 가지 유형의 토큰이 필요하다.
- 수 (실수, 가령 $3, 71, 23.45$),
- 식별자 (변수 이름, `i`, `j`, `a123`),
- 연산자 (`+`, `-`, `*`, `/`, $\cdots$),
- 입력 종결을 표기하기 위한 정지 토큰

토큰화 장치는 표현식의 의미나 구문에 관해 아무것도 모른다. 토큰화 장치는 (스페이스, 탭, 개행과 같은) 공백 문자를 이용해 토큰이 끝나거나 시작하는 곳을 결정한다. 공백 문자가 표현식에서 아무런 의미를 지니지 않기에, 공백 문자에 대해서는 토큰이 생성되지 않는다. (이와 유사하게 파이썬 인터프리터 주석은 토큰화 장치에 의해서 제거된다)

가령 `123456`과 `123 456`은 다른 토큰 열을 내놓고 `a12`와 `a 12` 또한 그렇다. 반면 `1+2`와 `1 + 2`는 모두 같은 토큰 열을 내놓는다. (즉 수 $1.0$, 기호 $+$, 수 $2.0$을 내놓는다).

가령 아래 표현식이 주어졌을 때
```
(abc12+27 * 23.0(12abc34
```
토큰화 장치는 다음 열을 생산한다.
```
Token: Symbol(()
Token: Identifier(abc12)
Token: Symbol(+)
Token: Number(27.0000)
Token: Symbol(*)
Token: Number(23.0000)
Token: Symbol(()
Token: Number(12.0000)
Token: Identifier(abc34)
Token: Stop
```
문자열이 무의미하더라도 (아니면 적어도 의미 있는 표현식이 아니라도) 토큰화 장치는 이를 자신의 규칙에 따라 토큰으로 쪼개는 데 어려움이 없다는 점에 다시금 주의하라. 토큰화 장치는 문자열의 구문이나 의미에 관한 아무 이해를 지니지 않는다.
## 구문 분석
구문 분석 (**파싱**) 과정에서 토큰화 장치에 의해 생산된 일련의 토큰은 검증되고 의미 있는 구조로 정돈된다. 구문 오류가 파싱 과정에서 감지된다. 구문 분석기는 **파서**라고 부르기도 한다.

구문 분석은 종종 **구문 트리** 또는 **파스 트리**라고 부르는 트리 구조로 토큰을 정돈한다. 우리의 경우 트리는 입력 표현식의 구조를 나타낸다. 가령 아래 표현식은 
```
( 1 - 2 ) * 3.0 + 4 / a12
```
아래 그림의 구문 트리로 파스된다. 파싱은 상이한 연산자의 우선 순위를 다루는 책임을 지닌다. `*`와 `/`를 결합하는 것은 `+`와 `-`를 결합하는 것보다 강하다.
![Fig1](\img\dat_2_1.png)
 